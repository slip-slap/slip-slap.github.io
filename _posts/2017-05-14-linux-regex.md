---
layout: post
title: "regex正则表达式"
keywords: ["regex", "intoduction"]
description: "regex"
category: "linux"
tags: ["code"]
---
{% include JB/setup %}



#### Intro 
+ 正则表达式描述了一种字符串匹配的模式，用来检查一个串是否含有某种子串，它不属于某种语言，但是不同的语言对它的支持不一样。
+ 正则表达式是一种引擎匹配工具，没啥牛逼的
+ 字符有本身的含义，比如字母，数字和下划线，如果需要赋予其别的含义只能通过转义符来实现，比如\w表示所有的字符
+ 在正则中，大多数的字符只是其本身的含义，只需要记住一些转义后的字符即可
+ * 在正则中已经失去其本来的含义，表示一种贪婪匹配
+ ？在正则中依然表示问号，添加转义字符后\?才表示匹配一次或者零次
+ （）括号依然表示括号本身的括号含义，添加转义符之后才表示一种子元素
+ []这个不好比较特殊，已经被转义

#### 类型
正则表达式和数学表达式的创建方法是一样的,因此正则表达式也用相应的一些运算符
<hr />

##### 字符
1. 特定字符 ‘X’   
2. 范围内字符:[0-9],[259], [a-zA-Z,:]  grep '[^0-9]' passwd

```shell
转义字符在[]内失去作用，‘[.]’ 表示匹配.,而不是匹配任意字符
```
3. .点号字符表示匹配任意字符
4. 边界字符

```shell
^: ^root  匹配输入字符串的开始位置， 注意与[^]的区别
$: false$ 匹配输入字符串的结尾位置
'^$' 表示空行
```

##### 元字符
1. \w: 匹配人体字类字符，包括下划线([A-Za-z0-9\_])
2. \W: 匹配任何非字类字符 '[^A-Za-z0-9\_]'
3. \b: 代表单词的分隔
3.  \*   匹配0次或者n次
4. \\+ 匹配1次或者n次
5. \\? 匹配0次或者1次
6. \\\{n\\\} 匹配n次
7. \\\{n,\\\} 至少匹配n次
8. \\\{n,m\\\} 至少匹配n次最多匹配m次

<hr />

##### 正则表达式组合


#### 实例

15到18位以X或者x或者数字结尾的身份证号

```shell
grep '[1-9]\([0-9]\{13\}\|[0-9]\{16\}\)[0-9Xx]' test
```

匹配密码

```shell
grep '$\w\+$'
```

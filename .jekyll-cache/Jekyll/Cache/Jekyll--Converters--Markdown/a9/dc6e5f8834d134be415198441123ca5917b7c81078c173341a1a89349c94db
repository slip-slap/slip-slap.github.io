I"Ð	
<h4 id="background">Background</h4>
<ol>
  <li>
    <p>Haskellâ€™s combination of purity, higher order functions, parameterized
algebraic data types, and typeclasses allows us to implement polymorphism on
a much higher level than possible in other languages.</p>
  </li>
  <li>
    <p>Functor is a typeclass, which is basically for things that can be mapped
over.</p>
  </li>
</ol>

<h4 id="example">Example</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</code></pre></div></div>
<ol>
  <li>$\textbf{fmap}$, the definition doesnâ€™t provide any default implementation
for it.</li>
  <li>The type of $\textbf{fmap}$ is interesting. In the definitions of typelcasses
so far, the type variable that played the role of the type in the typeclass
was a concrete type like the $\textbf{a}$ in $\textbf{(==) :: (Eq a) =&gt; a -&gt;
a -&gt; Bool}$</li>
  <li>but now, the $\textbf{f}$ is not a concrete type(a type that a value can
hold, like Int, Bool or Maybe String), but a type constructor that takes one
type parameter.</li>
</ol>

<h5 id="concrete">Concrete</h5>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span> <span class="n">fmap</span> <span class="o">=</span> <span class="n">map</span>
</code></pre></div></div>

<h4 id="galois">Galois</h4>
<ol>
  <li>Type constructors take other types as parameters to eventually produce
concrete types. That kind of reminds me of functions, which take values as
parameters to produce values.</li>
  <li>Weâ€™ve seen that type constructors can be partially applied($\textbf{Either
String}$ is a type that takes one type and produces a concrete type,
like$\textbf{Either String Int}$), just like functions can.</li>
</ol>

<h4 id="reference">Reference</h4>
<ol>
  <li><a href="https://bartoszmilewski.com/2014/01/14/functors-are-containers/">functor and container</a></li>
</ol>

:ET
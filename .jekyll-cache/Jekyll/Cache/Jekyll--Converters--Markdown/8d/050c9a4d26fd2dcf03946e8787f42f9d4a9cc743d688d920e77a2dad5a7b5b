I"
<h4 id="compiler-structure">Compiler Structure</h4>
<p>The compiler is consists of two parts: analysis and synthesis</p>
<ol>
  <li>Analysis part: often called the front end of the compiler
    <ul>
      <li>collects information about the source program and stores it in a data structure called a symbol
table, which is passed along with the intermediate representation to the synthesis part.</li>
      <li>Symbol table is used by all phases of the compiler</li>
    </ul>
  </li>
  <li>Synthesis part: the back end
    <ul>
      <li>construct the desired target program from the intermidiate representation and the information in
the symbol table</li>
    </ul>
  </li>
</ol>

<h4 id="procedure">Procedure</h4>
<ol>
  <li>Lexical Analysis or scanning: reads the stream of characters making up the source program and
groups the characters into meaningful sequences called lexemes, for each lexeme, the lexical
analyzer produces as ouput a token of the form:  &lt;token-name, attribute-value&gt;
    <ul>
      <li>In the token, the first component token-name is an abstract  symbol that is used during syntax
analysis.</li>
      <li>The second component attribute-value points to an entry in the symbol table for this token.</li>
      <li>Information from the symbol-table entry is needed for semantic analysis and code generation.</li>
    </ul>
  </li>
  <li>The second phase of the compiler is syntax analysis or parsing
    <ul>
      <li>The parser used the first components of the tokens produced by the lexical analyzer to create a
tree-like intermediate representation that depicts the grammatical structure of the token stream.</li>
      <li>A typical representation is a syntax tree in which each interior node represents an operation and
the children of the node represent the arguments of the operation.</li>
    </ul>
  </li>
  <li>Semantic Analysis: uses the syntax tree and the information in the symbol table to check the
source program for semantic consistency with the language definition
    <ul>
      <li>Type checking: where the compiler checks that each operator has matching operands. For example,
many programming language definitions require an array index to be an integer.</li>
      <li>The language specification may permit some type conversions called coercions</li>
    </ul>
  </li>
  <li>Intermediate Code Generation
    <ul>
      <li>In the process of translating a source program into target code, a compiler may construct one or
more intermediate representations, which can have a variety of forms.</li>
      <li>Syntax trees are a form of intermediate representation</li>
      <li>After syntax and semantic analysis of the source program, many compilers generate an explicit
low-levell or machine-like intermediate representation, which we can think of as a program for an
abstract machine.</li>
    </ul>
  </li>
  <li>Code Optimization</li>
  <li>Code Generation:</li>
</ol>

<h4 id="b">B</h4>
<ol>
  <li>The study of compilers is mainly a study of how we design the right mathematical models and
choose the right algorithms.</li>
</ol>

:ET
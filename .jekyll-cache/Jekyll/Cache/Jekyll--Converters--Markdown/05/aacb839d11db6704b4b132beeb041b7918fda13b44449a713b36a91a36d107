I"5
<h4 id="jargon">Jargon</h4>
<ol>
  <li>names of concrete types always start with a capital letter</li>
  <li>names of type variables start with a lowercase letter.</li>
  <li>
    <p>$\textbf{::}$ is read as “has type of”</p>
  </li>
  <li>Function type:</li>
</ol>

<h4 id="type">Type</h4>
<ol>
  <li>Tuples are types but they are dependent on their length as well as the types
of their components, so there is theoretically an infinite number of tuple
types, which is too many to cover
    <ul>
      <li>empty tuple () is also a type which can only have a single value: ()</li>
    </ul>
  </li>
</ol>

<h4 id="type-variable">Type variable</h4>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">:</span><span class="n">t</span> <span class="n">head</span>
<span class="n">head</span> <span class="o">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
</code></pre></div></div>

<ol>
  <li>what is this $\textbf{a}$ ? Is it a type, types are written in capital case,
so it can’t exactly be a type.</li>
  <li>Because it’s not in capital case it’s actually a $\textbf{type variable}$.</li>
  <li>That means that a can be of any type.</li>
</ol>

<h4 id="typeclasses">Typeclasses</h4>
<p>A typeclass is a sort of interface that defines some behavior. If a type is a
part of a typeclass, that means that it supports and implements the behavior the
typeclass describes</p>
<ul>
  <li>A lot of people coming from OOP get confused by typeclasses because they think
they are like classes in object oriented languages. Well, they’re not.</li>
  <li>You can think of them kind of as Java interfaces, only better.</li>
</ul>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">:</span><span class="n">t</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span>
<span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
</code></pre></div></div>

<ol>
  <li>$\textbf{=&gt;}$: everything before the $\textbf{=&gt;}$ is called a class
constraint</li>
</ol>

<h4 id="type-parameters">Type Parameters</h4>
<p>A value constructor can take some values parameters and then produce a new
value.</p>
<ul>
  <li>For instance, the $\textbf{Car}$ constructor takes three values and produces a
car value.</li>
  <li>In a similar manner, type constructors can take types as parameters to produce
new types. This might sound a bit too meta at first, but it’s not that
complicated, if you’re familiar with templates in C++, you’ll see some
parallels.</li>
</ul>

<h4 id="reference">reference</h4>
<ol>
  <li><a href="http://learnyouahaskell.com/introduction">haskell</a></li>
</ol>
:ET
I"
<h4 id="intro">Intro</h4>
<ul>
  <li>正则表达式描述了一种字符串匹配的模式，用来检查一个串是否含有某种子串，它不属于某种语言，但是不同的语言对它的支持不一样。</li>
  <li>正则表达式是一种引擎匹配工具，没啥牛逼的</li>
  <li>字符有本身的含义，比如字母，数字和下划线，如果需要赋予其别的含义只能通过转义符来实现，比如\w表示所有的字符</li>
  <li>在正则中，大多数的字符只是其本身的含义，只需要记住一些转义后的字符即可</li>
  <li>
    <ul>
      <li>在正则中已经失去其本来的含义，表示一种贪婪匹配</li>
    </ul>
  </li>
  <li>？在正则中依然表示问号，添加转义字符后\?才表示匹配一次或者零次</li>
  <li>（）括号依然表示括号本身的括号含义，添加转义符之后才表示一种子元素</li>
  <li>[]这个不好比较特殊，已经被转义</li>
</ul>

<h4 id="类型">类型</h4>
<p>正则表达式和数学表达式的创建方法是一样的,因此正则表达式也用相应的一些运算符</p>
<hr />

<h5 id="字符">字符</h5>
<ol>
  <li>特定字符 ‘X’</li>
  <li>范围内字符:[0-9],[259], [a-zA-Z,:]  grep ‘[^0-9]’ passwd</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>转义字符在[]内失去作用，‘[.]’ 表示匹配.,而不是匹配任意字符
</code></pre></div></div>
<ol>
  <li>.点号字符表示匹配任意字符</li>
  <li>边界字符</li>
</ol>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^: ^root  匹配输入字符串的开始位置， 注意与[^]的区别
<span class="nv">$:</span> <span class="nb">false</span><span class="nv">$ </span>匹配输入字符串的结尾位置
<span class="s1">'^$'</span> 表示空行
</code></pre></div></div>

<h5 id="元字符">元字符</h5>
<ol>
  <li>\w: 匹配人体字类字符，包括下划线([A-Za-z0-9_])</li>
  <li>\W: 匹配任何非字类字符 ‘[^A-Za-z0-9_]’</li>
  <li>\b: 代表单词的分隔</li>
  <li>*   匹配0次或者n次</li>
  <li>\+ 匹配1次或者n次</li>
  <li>\? 匹配0次或者1次</li>
  <li>\{n\} 匹配n次</li>
  <li>\{n,\} 至少匹配n次</li>
  <li>\{n,m\} 至少匹配n次最多匹配m次</li>
</ol>

<hr />

<h5 id="正则表达式组合">正则表达式组合</h5>

<h4 id="实例">实例</h4>

<p>15到18位以X或者x或者数字结尾的身份证号</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="s1">'[1-9]\([0-9]\{13\}\|[0-9]\{16\}\)[0-9Xx]'</span> <span class="nb">test</span>
</code></pre></div></div>

<p>匹配密码</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">grep</span> <span class="s1">'$\w\+$'</span>
</code></pre></div></div>
:ET
I"¿<h4 id="1-when-to-use">1. When to use?</h4>
<ol>
  <li>Copy constructor is called when a new object is created from an existing object, as a copy of the
existing object
    <ul>
      <li>pass an object to an argument of a function need copy constructor</li>
    </ul>
  </li>
  <li>Assignment operator is called when an already initialized object is assigned a new value from
another existing object.</li>
</ol>

<h4 id="2-why-argument-to-a-copy-constructor-must-be-passed-as-a-reference">2. Why argument to a copy constructor must be passed as a reference?</h4>
<p>A copy constructor is called when an object is passed by value. Copy constructor itself is a
function. So if we pass an argument by value in a copy constructor, a call to copy constructor would
be make to call copy constructor which becomes a non-terminating chain of calls. Therefore compiler
doesnâ€™t allow parameters to be passed by value.</p>

<h4 id="3-why-argument-to-a-copy-constructor-should-be-const">3. Why argument to a copy constructor should be const?</h4>
<ol>
  <li>one reason for passing const reference is, we should use const in c++ wherever possible so that
objects are not accidentally modified.</li>
  <li>Compiler created temporary objects can not be bound to non-const references.</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include&lt;iostream&gt;
</span><span class="k">class</span> <span class="nc">Student</span><span class="p">{</span>
	<span class="nl">public:</span>
		<span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span>  <span class="n">m_name</span><span class="p">){</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"create"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">Student</span><span class="p">(</span><span class="k">const</span> <span class="n">Student</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">){</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">"copy"</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">~</span><span class="n">Student</span><span class="p">(){</span>
		<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// the compiler will create a temporary object</span>
	<span class="c1">// then call the copy constructor, but, a temporarty can't be passed to a non-const argument</span>
	<span class="c1">// so we have to modify the argument to copy constructor with const keyword.</span>
	<span class="n">Student</span> <span class="n">robert</span><span class="o">=</span><span class="n">Student</span><span class="p">(</span><span class="s">"zhang"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="4-when-is-user-defined-conpy-constructor-needed">4. When is user-defined conpy constructor needed?</h4>
<ol>
  <li>if we donâ€™t define our own copy constructor, the C++ compiler creates a default copy constructor
 for each class which does a member-wise copy between objects</li>
  <li>The compiler created copy constructor works fine in general. We need to define our own copy
constructor only if an object has pointers or any runtime allocaton of resource like file handle,
a network connection.</li>
</ol>

<h4 id="example">Example</h4>
<p>standard library use copy constructor</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;list&gt;

void* operator new(size_t size){
	std::cout&lt;&lt;"allocate memory"&lt;&lt;std::endl;
	return std::malloc(size);
}

class Dot{
	public:
		Dot(){
			std::cout&lt;&lt;"new dot object"&lt;&lt;std::endl;
		}
		Dot(const Dot&amp; dot){
			std::cout&lt;&lt;"copy constructor"&lt;&lt;std::endl;
			this-&gt;a = dot.a;
			this-&gt;b = 1000;

		}
	int a,b;
	~Dot(){
		std::cout&lt;&lt;"destroy"&lt;&lt;std::endl;
	}
};

class Line{
	public:
	std::list&lt;Dot&gt; m_line;
	void addDot(Dot&amp; dot){
		m_line.push_back(dot);
	}
};

int main(){
	Line line;
	{
		Dot dot1;
		dot1.a = 3;dot1.b = 4;
		std::cout&lt;&lt;"________________"&lt;&lt;std::endl;
		line.addDot(dot1);
		std::cout&lt;&lt;"________________"&lt;&lt;std::endl;
		std::cout&lt;&lt;"address: "&lt;&lt;&amp;dot1&lt;&lt;std::endl;
	}
	for(std::list&lt;Dot&gt;::iterator itr =line.m_line.begin();itr!=line.m_line.end();itr++){
		std::cout&lt;&lt;"address: "&lt;&lt;&amp;itr&lt;&lt;std::endl;
		std::cout&lt;&lt;"a= "&lt;&lt;(*itr).a &lt;&lt;", b= "&lt;&lt;(*itr).b&lt;&lt;std::endl;
	}

}
</code></pre></div></div>

<h4 id="reference">reference</h4>
<ol>
  <li><a href="https://www.geeksforgeeks.org/copy-constructor-in-cpp/">copy constructor</a></li>
</ol>

:ET
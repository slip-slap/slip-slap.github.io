I"ï
<h4 id="terminology">Terminology</h4>
<ol>
  <li>predicates: To increase their flexibility and power, several algorithms allow
the user to pass user-defined operations, which they call internally. These
operations might be ordinary functions or function objects. If these
functions return a Boollean value, they are called predicates.</li>
</ol>

<h5 id="find">find</h5>
<p>find(beg, end, val)<br />
return è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘è¾“å…¥åºåˆ—ä¸­ç¬¬ä¸€ä¸ªç­‰äºvalçš„å…ƒç´ ã€‚<br />
find_if(beg, end, unaryPred)<br />
return è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼Œ æŒ‡å‘ç¬¬ä¸€ä¸ªæ»¡è¶³unaryPredçš„å…ƒç´  <br />
parameter å› ä¸ºè°“è¯çš„å‚æ•°ä¸ºå®¹å™¨çš„å…ƒç´ ç±»å‹ï¼Œå› æ­¤ï¼Œè°“è¯ä¸èƒ½æ˜¯æˆå‘˜å‡½æ•°</p>

<pre><code class="language-cpp,monokai">//è°“è¯
bool my_minus(int a){
	    return (a-1) == 2;
}
//ä¸»è°ƒå‡½æ•°
list&lt;int&gt; container;
container.push_back(3);
container.push_back(8);
auto var = find_if(container.begin(), container.end(),my_minus);
cout&lt;&lt;*var;
</code></pre>

<h4 id="å†™å®¹å™¨å…ƒç´ çš„ç®—æ³•">å†™å®¹å™¨å…ƒç´ çš„ç®—æ³•</h4>

<h5 id="fill_n">fill_n</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">itr</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">itr</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//ç®—æ³•éœ€è¦çš„åªæ˜¯è¿­ä»£å™¨ï¼Œæœ‰äº†è¿­ä»£å™¨å®ƒå°±å¾ˆå¼€å¿ƒäº†</span>
</code></pre></div></div>

<h4 id="æœ€å°å€¼å’Œæœ€å¤§å€¼">æœ€å°å€¼å’Œæœ€å¤§å€¼</h4>
<h5 id="minval1-val2-comp">min(val1, val2, comp)</h5>
<p>å‚æ•°å’Œè¿”å›ç±»å‹éƒ½æ˜¯constçš„å¼•ç”¨ï¼Œæ„å‘³ç€å¯¹è±¡ä¸ä¼šè¢«æ‹·è´</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool is_true(int a,int b){
	    return 0;
}
std::cout&lt;&lt;max(3,5,is_true);
</code></pre></div></div>

<p>minmax_element(beg, end, comp)<br />
param begå’Œendéƒ½æ˜¯è¿­ä»£å™¨<br />
      compæ˜¯è‡ªå®šä¹‰çš„æ¯”è¾ƒå‡½æ•°ï¼Œè¯¥æ¯”è¾ƒå‡½æ•°ä¸èƒ½æ˜¯ä¸€ä¸ªæˆå‘˜å‡½æ•°ã€‚ä¸ºä»€ä¹ˆ
	  æˆ‘çš„ç†è§£æ˜¯ï¼Œæˆå‘˜å‡½æ•°é»˜è®¤æœ‰ä¸€ä¸ªthisæŒ‡é’ˆä½œä¸ºå‚æ•°ã€‚è€Œè¯¥æ¯”è¾ƒå‡½æ•°çš„
	  å‚æ•°ä»…æœ‰ä¸¤ä¸ªï¼Œæ˜¯ä¸¤ä¸ªè¿­ä»£å™¨æ‰€æŒ‡å‘çš„å¯¹è±¡ã€‚
return è¿”å›å€¼æ˜¯ä¸€ä¸ªpairå®¹å™¨ï¼Œæˆå‘˜ä¸ºæŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool is_smaller(Point2d p1,Point2d p2){
	    return p1.x&lt;p2.x;
}
list&lt;Point2d&gt; container;
Point2d p1( 0,-1);
Point2d p11(1.5,0);
Point2d p2( 1, 1);
Point2d p3( 0, 1);
Point2d p4(-1, 1);
container.push_back(p1);
container.push_back(p11);
container.push_back(p2);
container.push_back(p3);
container.push_back(p4);
pair&lt;list&lt;Point2d&gt;::iterator,list&lt;Point2d&gt;::iterator&gt; var=minmax_element(container.begin(),container.end(),is_smaller);
std::cout&lt;&lt;*(var.first)&lt;&lt;*(var.second);    
//ç®€å•å†™æ³•
auto copy_var=minmax_element(container.begin(),container.end(),is_smaller);
</code></pre></div></div>
:ET
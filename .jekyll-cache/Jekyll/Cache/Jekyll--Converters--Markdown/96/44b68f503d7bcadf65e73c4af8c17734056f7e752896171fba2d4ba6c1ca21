I"
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
    <span class="n">putStrLn</span> <span class="s">"Hello, what's your name?"</span>
    <span class="n">name</span> <span class="o">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Hey "</span> <span class="o">++</span> <span class="n">name</span> <span class="o">++</span> <span class="s">", you rock!"</span><span class="p">)</span>
</code></pre></div></div>

<ol>
  <li>You can think of an I/O action as a box with little feet that will go out
into the real world and do something there (like write some graffiti on a
wall) and maybe bring back some data. Once it’s fetched that data for you,
the only way to open the box and get the data inside it is to use the &lt;-
construct.</li>
  <li>If we’re taking data out of an I/O action, we can only take it out when we’re
inside another I/O action. This is how Haskell manages to neatly separate the
pure and impure parts of our code.</li>
  <li>$\textbf{getLine}$ is in a sense impure because its result value is not
guaranteed to be the same when performed twice. That’s why it’s sort of
tainted with the IO type constructor and we can only get that data out in I/O
code. And because I/O code is tainted too, and computation that depends on
tainted I/O data will have a tainted result.</li>
  <li>I/O actions will only be performed when they are given a name of
$\textbf{main}$ or when they’re inside a bigger I/O action that we composed
with a do block. We can also use a do block to glue together a few I/O
actions and then we can use that I/O action in another do block and so on.</li>
</ol>
:ET
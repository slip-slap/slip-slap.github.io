I"
<ul id="markdown-toc">
  <li><a href="#intro" id="markdown-toc-intro">intro</a></li>
  <li><a href="#类加载过程" id="markdown-toc-类加载过程">类加载过程</a>    <ul>
      <li><a href="#源文件" id="markdown-toc-源文件">源文件</a></li>
      <li><a href="#加载" id="markdown-toc-加载">加载</a></li>
      <li><a href="#链接" id="markdown-toc-链接">链接</a>        <ul>
          <li><a href="#验证" id="markdown-toc-验证">验证</a></li>
          <li><a href="#准备" id="markdown-toc-准备">准备</a></li>
          <li><a href="#解析" id="markdown-toc-解析">解析</a></li>
        </ul>
      </li>
      <li><a href="#初始化" id="markdown-toc-初始化">初始化</a></li>
      <li><a href="#使用" id="markdown-toc-使用">使用</a></li>
      <li><a href="#卸载" id="markdown-toc-卸载">卸载</a></li>
    </ul>
  </li>
  <li><a href="#类加载器" id="markdown-toc-类加载器">类加载器</a>    <ul>
      <li><a href="#类与类加载器" id="markdown-toc-类与类加载器">类与类加载器</a></li>
      <li><a href="#类加载器-1" id="markdown-toc-类加载器-1">类加载器</a>        <ul>
          <li><a href="#启动类加载器" id="markdown-toc-启动类加载器">启动类加载器</a></li>
          <li><a href="#扩展类加载器" id="markdown-toc-扩展类加载器">扩展类加载器</a></li>
          <li><a href="#应用程序类加载器" id="markdown-toc-应用程序类加载器">应用程序类加载器</a></li>
        </ul>
      </li>
      <li><a href="#类加载器工作原理" id="markdown-toc-类加载器工作原理">类加载器工作原理</a></li>
    </ul>
  </li>
</ul>

<h3 id="intro">intro</h3>
<p>在C++语言中，没有类加载器的概念，那么这个类加载器相当于什么呢？</p>
<hr />

<h3 id="类加载过程">类加载过程</h3>
<p>类加载机制是加载类的，它所处理的东西只和类相关。</p>
<hr />

<h4 id="源文件">源文件</h4>
<p>java编译器把java代码编译为存储字节码的class文件，其他语言的编译器也可以把程序代码翻译成class文件，java虚拟机并不关心class的来源。</p>
<hr />

<h4 id="加载">加载</h4>
<p>加载阶段是最重要的阶段，也是开发期可控性最强的阶段，因为我们可以使用系统提供的类加载器，也可以自定义类加载器完成。</p>
<ol>
  <li>使用类全名获取定义此类的二进制字节流</li>
  <li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li>
  <li>在java堆中生成一个代表这个类的java.lang.Class对象;<font color="red">这个很有意思，字节码文件的后缀名为.class,生成的对象为Class对象</font></li>
</ol>
<hr />

<h4 id="链接">链接</h4>
<p>验证，准备和解析三个阶段统称为链接</p>
<hr />

<h5 id="验证">验证</h5>
<ol>
  <li>文件格式验证</li>
  <li>元数据验证</li>
  <li>字节码验证</li>
  <li>符号引用验证</li>
</ol>
<hr />

<h5 id="准备">准备</h5>
<p>准备阶段正式为类变量分配内存并设置类变量初始值的阶段，这些内存都在方法区进行分配</p>
<hr />

<h5 id="解析">解析</h5>
<p>解析阶段是虚拟机常量池内的符号引用直接替换为直接引用的过程。</p>
<ul>
  <li>符号引用: 用一组符号来描述所引用的目标对象，符号引用可以是任何形式的字面量，只要在使用时能无歧义地定位到目标即可。符号引用与虚拟机的内存布局无关，引用的目标对象不一定加载到内存中</li>
  <li>直接引用: 直接引用可以是直接指向目标对象的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机的内存布局相关。</li>
</ul>
<hr />

<h4 id="初始化">初始化</h4>
<hr />

<h4 id="使用">使用</h4>
<hr />

<h4 id="卸载">卸载</h4>
<hr />

<h3 id="类加载器">类加载器</h3>
<p>JVM的designer把类加载阶段中的类加载阶段放到Java虚拟机的外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码块称为类加载器。</p>
<hr />

<h4 id="类与类加载器">类与类加载器</h4>
<p>对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。两个类来源于同一个class文件，并且被同一个加载器加载，这两个类才相等。</p>
<hr />

<h4 id="类加载器-1">类加载器</h4>
<hr />

<h5 id="启动类加载器">启动类加载器</h5>
<p>Bootstrap ClassLoader: 负责加载JAVA_HOME\lib目录中能被虚拟机识别的类库加载到JVM内存中。该类加载器无法被Java程序直接使用</p>
<hr />

<h5 id="扩展类加载器">扩展类加载器</h5>
<p>Extension ClassLoader</p>
<hr />

<h5 id="应用程序类加载器">应用程序类加载器</h5>
<p>Application ClassLoader: 该类加载器为系统类加载器</p>
<hr />

<h4 id="类加载器工作原理">类加载器工作原理</h4>

:ET
I"
<h5 id="find">find</h5>
<p>find(beg, end, val)<br />
return 返回一个迭代器，指向输入序列中第一个等于val的元素。<br />
find_if(beg, end, unaryPred)<br />
return 返回一个迭代器， 指向第一个满足unaryPred的元素 <br />
parameter 因为谓词的参数为容器的元素类型，因此，谓词不能是成员函数</p>

<pre><code class="language-cpp,monokai">//谓词
bool my_minus(int a){
	    return (a-1) == 2;
}
//主调函数
list&lt;int&gt; container;
container.push_back(3);
container.push_back(8);
auto var = find_if(container.begin(), container.end(),my_minus);
cout&lt;&lt;*var;
</code></pre>

<h4 id="写容器元素的算法">写容器元素的算法</h4>

<h5 id="fill_n">fill_n</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">back_insert_iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">itr</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">container</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">itr</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span><span class="c1">//算法需要的只是迭代器，有了迭代器它就很开心了</span>
</code></pre></div></div>

<h4 id="排序">排序</h4>
<h5 id="sort">sort()</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">truct</span> <span class="n">my_point</span><span class="p">{</span>
	<span class="nl">public:</span>
	    <span class="n">my_point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">){</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">;</span>
	    <span class="p">}</span>
	    <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
	    <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
	   <span class="cm">/*
	   这里重载操作符的时候有两点要说清楚
	   1 属于对象的成员函数都存在隐藏的this指针，对于该函数而言，x属于某个对象的。
	   2 应该是语法默认规定，类内重载&lt;, 函数为const类型， 参数为const类型
	    否则会报如下错误
	    error: invalid operands to binary expression ('const my_point' and 'const my_point')
	    bool operator()(const _T1&amp; __x, const _T1&amp; __y) const {return __x &lt; __y;}
	   */</span>
	    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">my_point</span> <span class="o">&amp;</span><span class="n">my</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">my</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
	    <span class="p">}</span>
		<span class="c1">//第二种比较方法</span>
		<span class="kt">bool</span> <span class="n">is_compare</span><span class="p">(</span><span class="n">my_point</span> <span class="n">p1</span><span class="p">,</span> <span class="n">my_point</span> <span class="n">p2</span><span class="p">){</span>
			    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">x</span><span class="o">&lt;</span><span class="n">p2</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">//------------------------------------------------------</span>
		<span class="c1">//-------------------------------------------------------</span>
		<span class="n">list</span><span class="o">&lt;</span><span class="n">my_point</span><span class="o">&gt;</span> <span class="n">container</span><span class="p">;</span>
		<span class="n">my_point</span> <span class="n">p1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
		<span class="n">my_point</span> <span class="n">p2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
		<span class="n">my_point</span> <span class="n">p3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
		<span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
		<span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
		<span class="n">container</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p3</span><span class="p">);</span>
		<span class="n">container</span><span class="p">.</span><span class="n">sort</span><span class="p">();</span>
      <span class="c1">//container.sort(is_compare)</span>
<span class="p">};</span>
</code></pre></div></div>
<h4 id="最小值和最大值">最小值和最大值</h4>
<h5 id="minval1-val2-comp">min(val1, val2, comp)</h5>
<p>参数和返回类型都是const的引用，意味着对象不会被拷贝</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool is_true(int a,int b){
	    return 0;
}
std::cout&lt;&lt;max(3,5,is_true);
</code></pre></div></div>

<p>minmax_element(beg, end, comp)<br />
param beg和end都是迭代器<br />
      comp是自定义的比较函数，该比较函数不能是一个成员函数。为什么
	  我的理解是，成员函数默认有一个this指针作为参数。而该比较函数的
	  参数仅有两个，是两个迭代器所指向的对象。
return 返回值是一个pair容器，成员为指向对象的指针。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bool is_smaller(Point2d p1,Point2d p2){
	    return p1.x&lt;p2.x;
}
list&lt;Point2d&gt; container;
Point2d p1( 0,-1);
Point2d p11(1.5,0);
Point2d p2( 1, 1);
Point2d p3( 0, 1);
Point2d p4(-1, 1);
container.push_back(p1);
container.push_back(p11);
container.push_back(p2);
container.push_back(p3);
container.push_back(p4);
pair&lt;list&lt;Point2d&gt;::iterator,list&lt;Point2d&gt;::iterator&gt; var=minmax_element(container.begin(),container.end(),is_smaller);
std::cout&lt;&lt;*(var.first)&lt;&lt;*(var.second);    
//简单写法
auto copy_var=minmax_element(container.begin(),container.end(),is_smaller);
</code></pre></div></div>
:ET
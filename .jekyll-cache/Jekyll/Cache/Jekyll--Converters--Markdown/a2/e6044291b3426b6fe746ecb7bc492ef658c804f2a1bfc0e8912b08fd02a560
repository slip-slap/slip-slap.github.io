I"
<h3 id="intro">intro</h3>

<p>数据的初始化分为两种: <br /> 
直接初始化: 使用assignment operator<br /><br />
复制初始化: 使用(),将初始化值放在圆括号内。<br /><br />
对于类类型对象，直接初始化直接调用与实参匹配的构造函数。复制初始化
调用复制构造函数，然后使用复制构造函数将临时对象复制到正在创建的对象。
1 引用数据类型是一种复合类型，通过在变量名前添加&amp;来定义。</p>
<hr />

<h3 id="指针">指针</h3>

<h4 id="定义">定义</h4>

<p>指针: (point to)是一种复合类型。指针实现了对其他对象的间接访问。<br />
1 指针本身就是一个对象，允许对指针的赋值和拷贝。<br />
2 指针无需在定义时赋初值。<br /></p>
<hr />

<h4 id="空指针">空指针</h4>

<p>空指针不指向任何对象，在使用一个指针之前首先检查它是否为空。<br />
因为在写程序的时候，往往是空指针把程序搞崩溃。<br /></p>
<hr />

<h4 id="void">void*</h4>

<p>void* 一种特殊的指针类型，用于存放任意对象的地址。</p>

<h4 id="const和指针">const和指针</h4>

<p>指向常量的指针pointer to const 不能用于改变其所指对象的值。<br /></p>

<font color="green">要想存放常量对象的地址，只能使用指向常量的指针。</font>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//不能使用普通指针指向常量的地址
const double pi =3.14;  //pi 是常量，值不能改变
double *ptr = &amp;pi;      //错误: ptr是一个普通指针
//但是却可以使用const指针指向非const对象
double deta = 0.0;
const double *ptr = &amp;deta;
//为什么呢？const指针的含义是不可以通过指针改变所指向对象的值，至于指向的
//对象是不是const对象，它是不care的
</code></pre></div></div>

<hr />

<h3 id="引用">引用</h3>

<h4 id="左引用">左引用</h4>

<h5 id="定义-1">定义</h5>

<p>定义: 引用不是对象,引用是为已经存在的对象所起的另外一个名字.因为引用不是对象,所以不能定义引用的引用.<br /></p>
<hr />

<h5 id="reference-to-const">reference to const</h5>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//不能让一个非常量引用指向一个常量引用
 const int ci = 1024;
 int &amp;r1 = ci;
// 允许将一个const int&amp; 绑定到一个普通的int对象上
int i =42;
const int &amp;r2 = i;
//为什么呢？指导思想和指针是一样的。const的引用的含义是不可以通过引用改变
//所引用对象的值，至于引用对象是不是const的它不care
//const的意思是，我不允许所引用的对象通过我改变它的值。
//如果你能通过改变所引用的值，你随便，你开心就好
</code></pre></div></div>

<hr />

<h4 id="右值引用">右值引用</h4>

<p>#####产生的原因</p>

:ET
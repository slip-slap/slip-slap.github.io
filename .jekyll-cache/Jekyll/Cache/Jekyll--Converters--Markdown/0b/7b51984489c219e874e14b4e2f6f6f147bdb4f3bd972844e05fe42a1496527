I"ü
<h4 id="pricipal">Pricipal</h4>
<ol>
  <li>deal with the most trivial problem</li>
  <li>divide problem into two part, current problem and subproblem.</li>
  <li>return, if it has one, figure out the relationship between problem and
subplem
    <ul>
      <li>always you can use a math expression, for example, sum problem</li>
      <li>n+subproblem(n-1)</li>
    </ul>
  </li>
  <li><strong>Itâ€™s easy.</strong></li>
</ol>

<h4 id="definition">Definition</h4>
<ol>
  <li>Recursion: a function call itself.
    <ul>
      <li>it must stop somewhere, otherwise it will lead to infinite calling.</li>
      <li>it has two phases, calling phase(ascending phase), returning phase(descending
phase)</li>
    </ul>
  </li>
</ol>

<pre><code class="language-code">void foo(int n){
    if(n &gt; 0){
        1. calling: Ascending phase
        2. fun(n-1)
        3. returning: Descending time
    }
}
</code></pre>

<h4 id="analysisetracing">Analysise(tracing)</h4>
<ol>
  <li>a recursive function raise to a tree. keep the tree in mind.
    <pre><code class="language-code">void foo(n){
 if(n &gt; 0){
     foo(n-1);
     foo(n-2)
     print(n)
 }
}
foo(4)
</code></pre>
    <p><img src="/images/computer-science-algorithm-recursion.png" /></p>
  </li>
</ol>

<h4 id="difference-with-loops">difference with loops</h4>
<ol>
  <li>In loops, you only have ascending phase</li>
  <li>In recursive function, you have ascending phase and descending phase</li>
  <li>So you can utilize this to code easily.</li>
</ol>

<h4 id="recursion-type">Recursion Type</h4>
<ol>
  <li>Head recursion</li>
  <li>Tail recursion: recursive call is the last statement of the function;</li>
  <li>tree recursion: time complexity is O(n)
    <ul>
      <li>how to get this answer, draw recursive tree.</li>
    </ul>
  </li>
  <li>Indirect Recursion</li>
  <li>nested recursion</li>
</ol>

<h4 id="recursion-relation">Recursion Relation</h4>
<ol>
  <li>for sum of natural number, the relationship is:
    <ul>
      <li>$sum(n)=sum(n-1)+n$</li>
    </ul>
  </li>
  <li>for factorial, the relationship is;
    <ul>
      <li>$f(n) = n \times f(n-1)$</li>
    </ul>
  </li>
  <li>for fibnacci series, the relationship is:
    <ul>
      <li>$f(n) = f(n-1) + f(n-2)$</li>
    </ul>
  </li>
  <li>for tree height:
    <ul>
      <li>$h(root) = h(child) + 1$</li>
    </ul>
  </li>
  <li>we can express the relationship between recursion by formula, actualy, itâ€™s
very useful. <strong>itâ€™s the return value of function.</strong></li>
  <li>For a long time, I just donâ€™t know how to deal with return of recursion
function, now I know, based on this simple formula.</li>
  <li>recursion provide a way to think about problem we face, find the small
problem, nail it, then the big problem, kind of philosphy.</li>
</ol>

<h4 id="galois">Galois</h4>
<ol>
  <li>You can translate any recursion into for loop, but you need create a stack by
yourself.</li>
  <li>Compiler is no big deal, itâ€™s just pre-implement some algorithm. For example,
it implement stack structure to use recursion.</li>
</ol>

:ET